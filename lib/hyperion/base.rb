class Hyperion
	
	DEFAULTS = {
	  :host => '127.0.0.1',
	  :port => '6379'
	}
	
  class HyperionException < Exception; end
  class NoKey < HyperionException; end
	
  def self.hyperion_defaults(defaults) # DEPRECATED
    attribute_defaults(defaults)
  end
  def self.attribute_defaults(defaults)
    class_variable_set(:@@attr_defaults, defaults)
  end
  
  # TODO: It would be nice to refactor this
  def self.config(attrib)
    DEFAULTS[attrib]
  end
  
  def self.redis
    unless class_variable_defined?('@@redis') then
			begin
			  @@redis = Redis.new(:host => config(:host), :port => config(:port))
			
  			old_version = @@redis['hyperion_version']
  			if old_version then
  				Hyperion.logger.error("Hyperion datastore version is INCOMPATIBLE with your current hyperion gem. We'll still continue, but beware...") unless version_compatible?(old_version)
  			else
  				@@redis['hyperion_version'] = version
  			end
			rescue Errno::ECONNREFUSED => e
			  Hyperion.logger.error("Hyperion wasn't able to connect to your Redis server on #{config(:host)}:#{config(:port)}.")
        raise e
			end
		end
		@@redis
  end

  # :[ DEPRECATED, getting yanked as soon as possible
  def self.attr_accessor(*args)
    attribute(*args)
  end
  
  def self.attribute(*args)
    args.each{|attr|
      Hyperion.logger.debug("[Hyperion] Initializing attribute #{attr} on #{self.to_s}")
      module_eval( "def #{attr}() @#{attr}; end" )
      module_eval( "def #{attr}=(val) @#{attr} = val; end" )
    }
  end

  def save
    Hyperion.logger.debug("[Hyperion] Saving a #{self.class.to_s}:") if Hyperion::DEBUG
		
		rekey
		
    Hyperion.logger.debug("[Hyperion] Saving into #{full_key}: #{self.inspect}") if Hyperion::DEBUG
    Hyperion.redis[full_key] = self.serialize
    
    reindex!
  end

	def delete
		reindex!(:unstore => true)
		
	  Rails.logger.debug("[RS] Removingfrom #{full_key}: #{self.inspect}") if RedisStore::DEBUG
    RedisStore.redis[full_key] = nil
	end

  def initialize(opts = {})
    defaults = (self.class.class_variable_defined?('@@attr_defaults') ? self.class.class_variable_get('@@attr_defaults') : {})

    defaults.merge(opts).each {|k,v|
      self.send(k.to_s+'=',v)
    }
  end

  def self.deserialize(what)
    obj = YAML.load(what)
    obj.remember_initial_values
    
    obj
  end
  def serialize; YAML::dump(self); end

  def self.dump(output = STDOUT, lock = false)
    # TODO: lockability and progress
    output.write(<<-eos)
# Hyperion Dump
# Generated by @adrianpike's Hyperion gem.
    eos
    output.write('# Generated on ' + Time.current.to_s + "\n")
    output.write('# DB size is ' + redis.dbsize.to_s + "\n")

    redis.keys.each{|k|
      case redis.type(k)
      when "string"
        output.write({ k => redis.get(k)}.to_yaml)
      when "set"
        output.write({ k => redis.smembers(k) }.to_yaml)
      end
    }
  end


  # THIS IS MAD DANGEROUS AND UNTESTED, BEWARE DATA INTEGRITY
  def self.load(file = STDIN, truncate = true, lock = false)
    # TODO: lockability and progress    

    YAML.each_document( file ) do |ydoc|
      ydoc.each {|k,v|
        redis.del(k) if truncate

        case v.class.to_s
          when 'String'
            redis[k] = v
          when 'Array'
            v.each{|val|
              redis.sadd(k,val)
            }
          else
            p v.class
        end
      }
    end

  end

  # THIS IS TOTALLY IRREVERSIBLE YO
  def self.truncate!
    redis.flushdb
  end

end