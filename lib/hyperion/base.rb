class Hyperion
	
  class HyperionException < Exception; end
  class NoKey < HyperionException; end
	
  def self.hyperion_defaults(defaults)
    class_variable_set(:@@redis_defaults, defaults)
  end
  
  def self.redis
    unless class_variable_defined?('@@redis') then
			@@redis = Redis.new
			
			old_version = @@redis['hyperion_version']
			if old_version then
				Hyperion.logger.error("Hyperion datastore version is INCOMPATIBLE with your current hyperion gem.") unless version_compatible?(old_version)
			else
				@@redis['hyperion_version'] = version
			end
			
		end
		@@redis
  end

  def save
    Hyperion.logger.debug("[RS] Saving a #{self.class.to_s}:") if Hyperion::DEBUG
		
		rekey
		
    Hyperion.logger.debug("[RS] Saving into #{full_key}: #{self.inspect}") if Hyperion::DEBUG
    Hyperion.redis[full_key] = self.serialize
    
    reindex!
  end


  def initialize(opts = {})
    defaults = (self.class.class_variable_defined?('@@redis_defaults') ? self.class.class_variable_get('@@redis_defaults') : {})

    defaults.merge(opts).each {|k,v|
      self.send(k.to_s+'=',v)
    }
  end

  def self.deserialize(what); YAML.load(what); end
  def serialize; YAML::dump(self); end

  def self.dump(output = STDOUT, lock = false)
    # TODO: lockability and progress
    output.write(<<-eos)
# Hyperion Dump
# Generated by @adrianpike's Hyperion gem.
    eos
    output.write('# Generated on ' + Time.current.to_s + "\n")
    output.write('# DB size is ' + redis.dbsize.to_s + "\n")

    redis.keys.each{|k|
      case redis.type(k)
      when "string"
        output.write({ k => redis.get(k)}.to_yaml)
      when "set"
        output.write({ k => redis.smembers(k) }.to_yaml)
      end
    }
  end


  # THIS IS MAD DANGEROUS AND UNTESTED, BEWARE DATA INTEGRITY
  def self.load(file = STDIN, truncate = true, lock = false)
    # TODO: lockability and progress    

    YAML.each_document( file ) do |ydoc|
      ydoc.each {|k,v|
        redis.del(k) if truncate

        case v.class.to_s
          when 'String'
            redis[k] = v
          when 'Array'
            v.each{|val|
              redis.sadd(k,val)
            }
          else
            p v.class
        end
      }
    end

  end

  # THIS IS TOTALLY IRREVERSIBLE YO
  def self.truncate!
    redis.flushdb
  end

end